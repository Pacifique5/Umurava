This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.env.example
app.js
config/database.js
config/env.js
config/logger.js
controllers/authController.js
controllers/challengeController.js
controllers/communityController.js
controllers/contactController.js
controllers/dashboardController.js
controllers/userController.js
controllers/vulnerabilityController.js
middleware/authMiddleware.js
middleware/errorMiddleware.js
middleware/validateMiddleware.js
models/ChallengeModel.js
models/userModel.js
package.json
prisma/migrations/20250204123703_init/migration.sql
prisma/migrations/20260126124542_init/migration.sql
prisma/migrations/20260126130524_add_user_model/migration.sql
prisma/migrations/20260127191904_add_user_challenge_relation/migration.sql
prisma/migrations/20260129145841_add_target_url/migration.sql
prisma/migrations/20260129181140_add_vulnerability_reports/migration.sql
prisma/migrations/migration_lock.toml
prisma/schema.prisma
README.md
routes/authRoute.js
routes/challengeRoute.js
routes/communityRoute.js
routes/contactRoute.js
routes/dashboardRoute.js
routes/userRoute.js
routes/vulnerabilityRoute.js
server.js
services/challengeService.js
validations/challengeValidation.js
validations/user.validation.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".env.example">
# Backend Environment Variables

# Database Configuration
DATABASE_URL='postgresql://username:password@localhost:5432/cyberforge_db'

# JWT Secret (Generate a secure random string for production)
JWT_SECRET='your-super-secret-jwt-key-change-this-in-production'

# Server Configuration
PORT=5000
NODE_ENV=development

# For production deployment on Render:
# DATABASE_URL will be automatically provided by Render PostgreSQL
# JWT_SECRET will be auto-generated by Render
# PORT=10000 (Render default)
</file>

<file path="app.js">
const express = require("express");
const cors = require("cors");
const challengeRoutes = require("./routes/challengeRoute");
const authRoutes = require("./routes/authRoute");
const contactRoutes = require("./routes/contactRoute");
const userRoutes = require("./routes/userRoute");
const communityRoutes = require("./routes/communityRoute");
const dashboardRoutes = require("./routes/dashboardRoute");
const vulnerabilityRoutes = require("./routes/vulnerabilityRoute");
const errorHandler = require("./middleware/errorMiddleware");

const app = express();

app.use(cors());
app.use(express.json());

// Health check endpoint
app.get("/api/health", (req, res) => {
  res.status(200).json({
    status: "OK",
    message: "CyberForge API is running",
    timestamp: new Date().toISOString(),
    environment: process.env.NODE_ENV || 'development'
  });
});

// Routes
app.use("/api/challenges", challengeRoutes);
app.use("/api/auth", authRoutes);
app.use("/api/contact", contactRoutes);
app.use("/api/user", userRoutes);
app.use("/api/community", communityRoutes);
app.use("/api/dashboard", dashboardRoutes);
app.use("/api/vulnerabilities", vulnerabilityRoutes);

app.use(errorHandler);

module.exports = app;
</file>

<file path="config/database.js">
const { PrismaClient } = require("@prisma/client");

const prisma = new PrismaClient();

prisma.$connect()
    .then(() => console.log("‚úÖ Connected to PostgreSQL"))
    .catch(err => console.error("‚ùå Database connection error:", err));

module.exports = prisma;
</file>

<file path="config/env.js">
require("dotenv").config();

module.exports = {
    PORT: process.env.PORT || 5000,
};
</file>

<file path="config/logger.js">
const logger = (message) => {
    console.log(`[LOG]: ${message}`);
};

module.exports = logger;
</file>

<file path="controllers/authController.js">
const bcrypt = require("bcryptjs");
const jwt = require("jsonwebtoken");
const { PrismaClient } = require("@prisma/client");

const prisma = new PrismaClient();

class AuthController {
    static async signup(req, res) {
        try {
            console.log("üìù Signup request received:", req.body);
            const { email, password, firstName, lastName } = req.body;

            // Check if user already exists
            const existingUser = await prisma.user.findUnique({
                where: { email }
            });

            if (existingUser) {
                console.log("‚ùå User already exists:", email);
                return res.status(400).json({ message: "User already exists" });
            }

            // Hash password
            const hashedPassword = await bcrypt.hash(password, 12);

            // Create user
            const user = await prisma.user.create({
                data: {
                    email,
                    password: hashedPassword,
                    firstName,
                    lastName
                }
            });

            console.log("‚úÖ User created successfully:", user.email);

            // Generate JWT token
            const token = jwt.sign(
                { userId: user.id, email: user.email },
                process.env.JWT_SECRET || "your-secret-key",
                { expiresIn: "7d" }
            );

            res.status(201).json({
                message: "User created successfully",
                token,
                user: {
                    id: user.id,
                    email: user.email,
                    firstName: user.firstName,
                    lastName: user.lastName
                }
            });
        } catch (error) {
            console.error("‚ùå Signup error:", error);
            res.status(500).json({ message: "Internal server error" });
        }
    }

    static async login(req, res) {
        try {
            console.log("üîê Login request received:", req.body.email);
            const { email, password } = req.body;

            // Find user
            const user = await prisma.user.findUnique({
                where: { email }
            });

            if (!user) {
                console.log("‚ùå User not found:", email);
                return res.status(401).json({ message: "Invalid credentials" });
            }

            // Check password
            const isValidPassword = await bcrypt.compare(password, user.password);
            if (!isValidPassword) {
                console.log("‚ùå Invalid password for:", email);
                return res.status(401).json({ message: "Invalid credentials" });
            }

            console.log("‚úÖ Login successful:", email);

            // Generate JWT token
            const token = jwt.sign(
                { userId: user.id, email: user.email },
                process.env.JWT_SECRET || "your-secret-key",
                { expiresIn: "7d" }
            );

            res.json({
                message: "Login successful",
                token,
                user: {
                    id: user.id,
                    email: user.email,
                    firstName: user.firstName,
                    lastName: user.lastName
                }
            });
        } catch (error) {
            console.error("‚ùå Login error:", error);
            res.status(500).json({ message: "Internal server error" });
        }
    }

    static async logout(req, res) {
        res.json({ message: "Logout successful" });
    }

    static async getMe(req, res) {
        try {
            // This would require auth middleware to get user from token
            res.json({ message: "Get current user - requires auth middleware" });
        } catch (error) {
            res.status(500).json({ message: "Internal server error" });
        }
    }
}

module.exports = AuthController;
</file>

<file path="controllers/challengeController.js">
const ChallengeService = require("../services/challengeService");

const ChallengeController = {
    async create(req, res) {
        try {
            console.log("üöÄ Backend: Challenge creation request received");
            console.log("üì§ Backend: Request body:", req.body);
            console.log("üë§ Backend: User from auth middleware:", req.user);
            
            // Add the user ID to the challenge data
            const challengeData = {
                ...req.body,
                createdBy: req.user?.id
            };
            
            console.log("üìù Backend: Challenge data to create:", challengeData);
            
            const challenge = await ChallengeService.createChallenge(challengeData);
            console.log("‚úÖ Backend: Challenge created successfully:", challenge);
            res.status(201).json(challenge);
        } catch (error) {
            console.error("‚ùå Backend: Error creating challenge:", error);
            console.error("‚ùå Backend: Error stack:", error.stack);
            res.status(500).json({ message: "Error creating challenge", error: error.message });
        }
    },

    async getAll(req, res) {
        try {
            const filters = {
                search: req.query.search || "",
                sortBy: req.query.sortBy || "createdAt",
                order: req.query.order || "desc",
                page: req.query.page || 1,
                limit: req.query.limit || 10,
            };

            const challenges = await ChallengeService.getAllChallenges(filters);
            res.status(200).json(challenges);
        } catch (error) {
            res.status(500).json({ message: "Error fetching challenges", error });
        }
    },

    async getById(req, res) {
        try {
            const challenge = await ChallengeService.getChallengeById(req.params.id);
            if (!challenge) {
                return res.status(404).json({ message: "Challenge not found" });
            }
            res.status(200).json(challenge);
        } catch (error) {
            res.status(500).json({ message: "Error fetching challenge", error });
        }
    },

    async update(req, res) {
        try {
            const updatedChallenge = await ChallengeService.updateChallenge(req.params.id, req.body);
            res.status(200).json(updatedChallenge);
        } catch (error) {
            res.status(500).json({ message: "Error updating challenge", error });
        }
    },

    async delete(req, res) {
        try {
            await ChallengeService.deleteChallenge(req.params.id);
            res.status(204).send();
        } catch (error) {
            res.status(500).json({ message: "Error deleting challenge", error });
        }
    }
};

module.exports = ChallengeController;
</file>

<file path="controllers/communityController.js">
class CommunityController {
    static async getCommunityData(req, res) {
        try {
            const communityData = {
                totalMembers: 1250,
                activeChallenges: 8,
                completedProjects: 45,
                topSkills: ["JavaScript", "Python", "React", "Node.js", "Machine Learning"],
                recentActivities: [
                    {
                        id: 1,
                        user: "Alice Johnson",
                        action: "completed",
                        challenge: "Web Development Bootcamp",
                        timestamp: "2024-01-20T10:30:00Z"
                    },
                    {
                        id: 2,
                        user: "Bob Smith",
                        action: "joined",
                        challenge: "AI/ML Challenge",
                        timestamp: "2024-01-20T09:15:00Z"
                    }
                ]
            };

            res.json(communityData);
        } catch (error) {
            console.error("Get community data error:", error);
            res.status(500).json({ message: "Internal server error" });
        }
    }
}

module.exports = CommunityController;
</file>

<file path="controllers/contactController.js">
class ContactController {
    static async submitContact(req, res) {
        try {
            const { name, email, message } = req.body;

            // Here you would typically save to database or send email
            console.log("Contact form submission:", { name, email, message });

            res.json({
                message: "Contact form submitted successfully",
                data: { name, email, message }
            });
        } catch (error) {
            console.error("Contact form error:", error);
            res.status(500).json({ message: "Internal server error" });
        }
    }
}

module.exports = ContactController;
</file>

<file path="controllers/dashboardController.js">
const { PrismaClient } = require("@prisma/client");

const prisma = new PrismaClient();

class DashboardController {
    static async getDashboardStats(req, res) {
        try {
            console.log("üìä Dashboard stats requested by user:", req.user.email);

            // Get total challenges
            const totalChallenges = await prisma.challenge.count();

            // Get user's challenges (if they created any)
            const userChallenges = await prisma.challenge.count({
                where: { createdBy: req.user.id }
            });

            // Get recent challenges
            const recentChallenges = await prisma.challenge.findMany({
                take: 5,
                orderBy: { createdAt: 'desc' },
                select: {
                    id: true,
                    title: true,
                    description: true,
                    difficulty: true,
                    duration: true,
                    createdAt: true
                }
            });

            const stats = {
                totalChallenges,
                userChallenges,
                completedChallenges: 0, // TODO: Implement when we have submissions
                ongoingChallenges: totalChallenges,
                recentChallenges
            };

            console.log("‚úÖ Dashboard stats retrieved successfully:", stats);
            res.json(stats);
        } catch (error) {
            console.error("‚ùå Dashboard stats error:", error);
            res.status(500).json({ message: "Internal server error" });
        }
    }

    static async getUserProfile(req, res) {
        try {
            console.log("üë§ User profile requested:", req.user.email);

            const user = {
                id: req.user.id,
                email: req.user.email,
                firstName: req.user.firstName,
                lastName: req.user.lastName,
                fullName: `${req.user.firstName} ${req.user.lastName}`,
                joinedAt: req.user.createdAt
            };

            res.json(user);
        } catch (error) {
            console.error("‚ùå User profile error:", error);
            res.status(500).json({ message: "Internal server error" });
        }
    }
}

module.exports = DashboardController;
</file>

<file path="controllers/userController.js">
const prisma = require("../config/database");
const bcrypt = require("bcryptjs");

class UserController {
    static async getProfile(req, res) {
        try {
            const user = await prisma.user.findUnique({
                where: { id: req.user.id },
                select: {
                    id: true,
                    firstName: true,
                    lastName: true,
                    email: true,
                    createdAt: true
                }
            });

            if (!user) {
                return res.status(404).json({ message: "User not found" });
            }

            res.json(user);
        } catch (error) {
            console.error("Get profile error:", error);
            res.status(500).json({ message: "Internal server error" });
        }
    }

    static async updateProfile(req, res) {
        try {
            const { firstName, lastName, email } = req.body;
            
            // Check if email is already taken by another user
            if (email && email !== req.user.email) {
                const existingUser = await prisma.user.findUnique({
                    where: { email }
                });
                
                if (existingUser) {
                    return res.status(400).json({ message: "Email already in use" });
                }
            }

            const updatedUser = await prisma.user.update({
                where: { id: req.user.id },
                data: {
                    firstName: firstName || req.user.firstName,
                    lastName: lastName || req.user.lastName,
                    email: email || req.user.email
                },
                select: {
                    id: true,
                    firstName: true,
                    lastName: true,
                    email: true,
                    createdAt: true
                }
            });
            
            res.json({
                message: "Profile updated successfully",
                user: updatedUser
            });
        } catch (error) {
            console.error("Update profile error:", error);
            res.status(500).json({ message: "Internal server error" });
        }
    }

    static async changePassword(req, res) {
        try {
            const { currentPassword, newPassword } = req.body;

            if (!currentPassword || !newPassword) {
                return res.status(400).json({ message: "Current password and new password are required" });
            }

            // Get user with password
            const user = await prisma.user.findUnique({
                where: { id: req.user.id }
            });

            if (!user) {
                return res.status(404).json({ message: "User not found" });
            }

            // Verify current password
            const isCurrentPasswordValid = await bcrypt.compare(currentPassword, user.password);
            if (!isCurrentPasswordValid) {
                return res.status(400).json({ message: "Current password is incorrect" });
            }

            // Hash new password
            const hashedNewPassword = await bcrypt.hash(newPassword, 10);

            // Update password
            await prisma.user.update({
                where: { id: req.user.id },
                data: { password: hashedNewPassword }
            });

            res.json({ message: "Password changed successfully" });
        } catch (error) {
            console.error("Change password error:", error);
            res.status(500).json({ message: "Internal server error" });
        }
    }

    static async updateEmail(req, res) {
        try {
            const { newEmail, password } = req.body;

            if (!newEmail || !password) {
                return res.status(400).json({ message: "New email and password are required" });
            }

            // Get user with password
            const user = await prisma.user.findUnique({
                where: { id: req.user.id }
            });

            if (!user) {
                return res.status(404).json({ message: "User not found" });
            }

            // Verify password
            const isPasswordValid = await bcrypt.compare(password, user.password);
            if (!isPasswordValid) {
                return res.status(400).json({ message: "Password is incorrect" });
            }

            // Check if email is already taken
            const existingUser = await prisma.user.findUnique({
                where: { email: newEmail }
            });
            
            if (existingUser) {
                return res.status(400).json({ message: "Email already in use" });
            }

            // Update email
            const updatedUser = await prisma.user.update({
                where: { id: req.user.id },
                data: { email: newEmail },
                select: {
                    id: true,
                    firstName: true,
                    lastName: true,
                    email: true,
                    createdAt: true
                }
            });

            res.json({ 
                message: "Email updated successfully",
                user: updatedUser
            });
        } catch (error) {
            console.error("Update email error:", error);
            res.status(500).json({ message: "Internal server error" });
        }
    }

    static async uploadProfileImage(req, res) {
        try {
            // For now, just return success - file upload would need multer middleware
            res.json({ 
                message: "Profile image upload functionality not yet implemented",
                note: "This would require file upload middleware like multer"
            });
        } catch (error) {
            console.error("Upload profile image error:", error);
            res.status(500).json({ message: "Internal server error" });
        }
    }

    static async getDashboardStats(req, res) {
        try {
            // Get user's challenge statistics
            const totalChallenges = await prisma.challenge.count();
            const userReports = await prisma.vulnerabilityReport.count({
                where: { userId: req.user.id }
            });
            const userChallenges = await prisma.vulnerabilityReport.findMany({
                where: { userId: req.user.id },
                select: { challengeId: true },
                distinct: ['challengeId']
            });

            const stats = {
                totalChallenges,
                completedChallenges: userChallenges.length,
                ongoingChallenges: Math.max(0, userChallenges.length - userReports),
                totalReports: userReports,
                rank: Math.floor(Math.random() * 100) + 1, // Mock ranking
                skillsLearned: Math.floor(userReports / 2) + 1
            };

            res.json(stats);
        } catch (error) {
            console.error("Get dashboard stats error:", error);
            res.status(500).json({ message: "Internal server error" });
        }
    }
}

module.exports = UserController;
</file>

<file path="controllers/vulnerabilityController.js">
const prisma = require("../config/database");

const VulnerabilityController = {
    async submitReports(req, res) {
        try {
            console.log("üöÄ Backend: Vulnerability reports submission request");
            console.log("üì§ Backend: Request body:", req.body);
            console.log("üë§ Backend: User from auth middleware:", req.user);
            
            const { challengeId, reports } = req.body;
            
            if (!challengeId || !reports || !Array.isArray(reports)) {
                return res.status(400).json({ 
                    message: "Challenge ID and reports array are required" 
                });
            }

            if (reports.length === 0) {
                return res.status(400).json({ 
                    message: "At least one vulnerability report is required" 
                });
            }

            // Create vulnerability reports in database
            const createdReports = [];
            
            for (const report of reports) {
                const vulnerabilityReport = await prisma.vulnerabilityReport.create({
                    data: {
                        challengeId,
                        userId: req.user.id,
                        title: report.title,
                        severity: report.severity,
                        category: report.category || null,
                        description: report.description,
                        stepsToReproduce: report.stepsToReproduce || null,
                        impact: report.impact || null,
                        recommendation: report.recommendation || null,
                        evidence: report.evidence || null,
                        status: 'submitted'
                    }
                });
                createdReports.push(vulnerabilityReport);
            }

            console.log(`‚úÖ Backend: Successfully created ${createdReports.length} vulnerability reports`);
            
            res.status(201).json({
                message: `Successfully submitted ${createdReports.length} vulnerability report(s)`,
                reports: createdReports
            });
        } catch (error) {
            console.error("‚ùå Backend: Error submitting vulnerability reports:", error);
            console.error("‚ùå Backend: Error stack:", error.stack);
            res.status(500).json({ 
                message: "Error submitting vulnerability reports", 
                error: error.message 
            });
        }
    },

    async getReportsByChallenge(req, res) {
        try {
            const { challengeId } = req.params;
            
            const reports = await prisma.vulnerabilityReport.findMany({
                where: {
                    challengeId,
                    userId: req.user.id
                },
                orderBy: {
                    createdAt: 'desc'
                }
            });

            res.status(200).json(reports);
        } catch (error) {
            console.error("‚ùå Backend: Error fetching vulnerability reports:", error);
            res.status(500).json({ 
                message: "Error fetching vulnerability reports", 
                error: error.message 
            });
        }
    },

    async getAllUserReports(req, res) {
        try {
            const reports = await prisma.vulnerabilityReport.findMany({
                where: {
                    userId: req.user.id
                },
                include: {
                    challenge: {
                        select: {
                            title: true
                        }
                    }
                },
                orderBy: {
                    createdAt: 'desc'
                }
            });

            res.status(200).json(reports);
        } catch (error) {
            console.error("‚ùå Backend: Error fetching user vulnerability reports:", error);
            res.status(500).json({ 
                message: "Error fetching user vulnerability reports", 
                error: error.message 
            });
        }
    }
};

module.exports = VulnerabilityController;
</file>

<file path="middleware/authMiddleware.js">
const jwt = require("jsonwebtoken");
const { PrismaClient } = require("@prisma/client");

const prisma = new PrismaClient();

const authMiddleware = async (req, res, next) => {
    try {
        const authHeader = req.headers.authorization;
        
        if (!authHeader || !authHeader.startsWith('Bearer ')) {
            console.log("üîí Auth middleware: No token provided");
            return res.status(401).json({ message: "Access denied. No token provided." });
        }

        const token = authHeader.substring(7); // Remove 'Bearer ' prefix
        
        try {
            const decoded = jwt.verify(token, process.env.JWT_SECRET || "your-secret-key");
            console.log("‚úÖ Auth middleware: Token verified for user:", decoded.email);
            
            // Get user from database
            const user = await prisma.user.findUnique({
                where: { id: decoded.userId },
                select: {
                    id: true,
                    email: true,
                    firstName: true,
                    lastName: true,
                    createdAt: true
                }
            });

            if (!user) {
                console.log("‚ùå Auth middleware: User not found:", decoded.userId);
                return res.status(401).json({ message: "Invalid token. User not found." });
            }

            req.user = user;
            next();
        } catch (jwtError) {
            console.log("‚ùå Auth middleware: Invalid token:", jwtError.message);
            return res.status(401).json({ message: "Invalid token." });
        }
    } catch (error) {
        console.error("‚ùå Auth middleware error:", error);
        res.status(500).json({ message: "Internal server error" });
    }
};

module.exports = authMiddleware;
</file>

<file path="middleware/errorMiddleware.js">
const errorHandler = (err, _req, res, _next) => {
    res.status(500).json({ message: err.message || "Internal Server Error" });
};

module.exports = errorHandler;
</file>

<file path="middleware/validateMiddleware.js">
const { validationResult } = require("express-validator");

const validate = (req, res, next) => {
    console.log("üîç Validation middleware: Checking request body:", req.body);
    
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
        console.error("‚ùå Validation errors:", errors.array());
        return res.status(400).json({ 
            message: "Validation failed",
            errors: errors.array() 
        });
    }
    
    console.log("‚úÖ Validation passed");
    next();
};

module.exports = validate;
</file>

<file path="models/ChallengeModel.js">
const { Prisma } = require("@prisma/client");

module.exports = {
    Challenge: Prisma.ChallengeGetPayload({})
};
</file>

<file path="models/userModel.js">

</file>

<file path="package.json">
{
  "name": "cyberforge-api",
  "version": "1.0.0",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js",
    "build": "npx prisma generate",
    "migrate": "npx prisma migrate deploy",
    "db:push": "npx prisma db push"
  },
  "keywords": [
    "cybersecurity",
    "education",
    "vulnerability",
    "assessment"
  ],
  "author": "CyberForge Team",
  "license": "MIT",
  "description": "CyberForge API - Cybersecurity Education Platform Backend",
  "dependencies": {
    "@prisma/client": "^6.3.1",
    "bcryptjs": "^3.0.3",
    "body-parser": "^1.20.3",
    "cors": "^2.8.5",
    "dotenv": "^16.4.7",
    "express": "^4.21.2",
    "express-validator": "^7.2.1",
    "jsonwebtoken": "^9.0.3",
    "pg": "^8.13.1",
    "pg-promise": "^11.10.2",
    "prisma": "^6.3.1"
  },
  "devDependencies": {
    "nodemon": "^3.1.9"
  },
  "engines": {
    "node": ">=18.0.0"
  }
}
</file>

<file path="prisma/migrations/20250204123703_init/migration.sql">
-- CreateTable
CREATE TABLE "Challenge" (
    "id" TEXT NOT NULL,
    "title" TEXT NOT NULL,
    "description" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "Challenge_pkey" PRIMARY KEY ("id")
);
</file>

<file path="prisma/migrations/20260126124542_init/migration.sql">
/*
  Warnings:

  - Added the required column `difficulty` to the `Challenge` table without a default value. This is not possible if the table is not empty.
  - Added the required column `duration` to the `Challenge` table without a default value. This is not possible if the table is not empty.

*/
-- AlterTable
ALTER TABLE "Challenge" ADD COLUMN     "difficulty" TEXT NOT NULL,
ADD COLUMN     "duration" INTEGER NOT NULL;
</file>

<file path="prisma/migrations/20260126130524_add_user_model/migration.sql">
-- CreateTable
CREATE TABLE "User" (
    "id" TEXT NOT NULL,
    "email" TEXT NOT NULL,
    "password" TEXT NOT NULL,
    "firstName" TEXT NOT NULL,
    "lastName" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "User_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "User_email_key" ON "User"("email");
</file>

<file path="prisma/migrations/20260127191904_add_user_challenge_relation/migration.sql">
-- AlterTable
ALTER TABLE "Challenge" ADD COLUMN     "createdBy" TEXT;

-- AddForeignKey
ALTER TABLE "Challenge" ADD CONSTRAINT "Challenge_createdBy_fkey" FOREIGN KEY ("createdBy") REFERENCES "User"("id") ON DELETE SET NULL ON UPDATE CASCADE;
</file>

<file path="prisma/migrations/20260129145841_add_target_url/migration.sql">
-- AlterTable
ALTER TABLE "Challenge" ADD COLUMN     "targetUrl" TEXT;
</file>

<file path="prisma/migrations/20260129181140_add_vulnerability_reports/migration.sql">
-- CreateTable
CREATE TABLE "VulnerabilityReport" (
    "id" TEXT NOT NULL,
    "challengeId" TEXT NOT NULL,
    "userId" TEXT NOT NULL,
    "title" TEXT NOT NULL,
    "severity" TEXT NOT NULL,
    "category" TEXT,
    "description" TEXT NOT NULL,
    "stepsToReproduce" TEXT,
    "impact" TEXT,
    "recommendation" TEXT,
    "evidence" TEXT,
    "status" TEXT NOT NULL DEFAULT 'submitted',
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "VulnerabilityReport_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE INDEX "VulnerabilityReport_challengeId_idx" ON "VulnerabilityReport"("challengeId");

-- CreateIndex
CREATE INDEX "VulnerabilityReport_userId_idx" ON "VulnerabilityReport"("userId");

-- AddForeignKey
ALTER TABLE "VulnerabilityReport" ADD CONSTRAINT "VulnerabilityReport_challengeId_fkey" FOREIGN KEY ("challengeId") REFERENCES "Challenge"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "VulnerabilityReport" ADD CONSTRAINT "VulnerabilityReport_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE CASCADE ON UPDATE CASCADE;
</file>

<file path="prisma/migrations/migration_lock.toml">
# Please do not edit this file manually
# It should be added in your version-control system (e.g., Git)
provider = "postgresql"
</file>

<file path="prisma/schema.prisma">
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                    String                 @id @default(uuid())
  email                 String                 @unique
  password              String
  firstName             String
  lastName              String
  createdAt             DateTime               @default(now())
  updatedAt             DateTime               @updatedAt
  challenges            Challenge[]
  vulnerabilityReports  VulnerabilityReport[]
}

model Challenge {
  id                    String                 @id @default(uuid())
  title                 String
  description           String
  difficulty            String
  duration              Int
  targetUrl             String?                // Optional target URL for security challenges
  createdAt             DateTime               @default(now())
  createdBy             String?
  creator               User?                  @relation(fields: [createdBy], references: [id])
  vulnerabilityReports  VulnerabilityReport[]
}

model VulnerabilityReport {
  id                String   @id @default(uuid())
  challengeId       String
  userId            String
  title             String
  severity          String   // critical, high, medium, low, info
  category          String?
  description       String
  stepsToReproduce  String?
  impact            String?
  recommendation    String?
  evidence          String?
  status            String   @default("submitted") // submitted, reviewed, accepted, rejected
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  
  challenge         Challenge @relation(fields: [challengeId], references: [id], onDelete: Cascade)
  user              User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([challengeId])
  @@index([userId])
}
</file>

<file path="README.md">
# üõ°Ô∏è CyberForge API - Backend Server

The backend API server for CyberForge, a comprehensive cybersecurity education platform that enables vulnerability assessment challenges and security learning.

## üåê **Live API**

- **Production API:** [https://cyberforge-api.onrender.com](https://cyberforge-api.onrender.com)
- **Health Check:** [https://cyberforge-api.onrender.com/api/health](https://cyberforge-api.onrender.com/api/health)

## üöÄ **Technology Stack**

- **Runtime:** Node.js with Express.js
- **Database:** PostgreSQL with Prisma ORM
- **Authentication:** JWT with bcryptjs
- **Validation:** Express Validator
- **Deployment:** Render with automatic migrations

## üìä **API Endpoints**

### **Health Check**
- `GET /api/health` - Server health status

### **Authentication**
- `POST /api/auth/register` - User registration
- `POST /api/auth/login` - User login

### **Challenges**
- `GET /api/challenges` - List all challenges
- `POST /api/challenges` - Create new challenge (Auth required)
- `GET /api/challenges/:id` - Get challenge details

### **Vulnerability Reports**
- `POST /api/vulnerabilities/submit` - Submit vulnerability reports (Auth required)
- `GET /api/vulnerabilities/challenge/:id` - Get reports for challenge (Auth required)
- `GET /api/vulnerabilities/user` - Get user's reports (Auth required)

### **User Management**
- `GET /api/user/profile` - Get user profile (Auth required)
- `PUT /api/user/profile` - Update profile (Auth required)
- `PUT /api/user/change-password` - Change password (Auth required)
- `PUT /api/user/update-email` - Update email (Auth required)
- `GET /api/user/dashboard-stats` - Get dashboard statistics (Auth required)

### **Dashboard**
- `GET /api/dashboard/stats` - Get dashboard overview (Auth required)

### **Community**
- `GET /api/community` - Get community data

### **Contact**
- `POST /api/contact` - Submit contact form

## üõ†Ô∏è **Local Development Setup**

### **Prerequisites**
- Node.js 18+
- PostgreSQL database
- Git

### **Installation**
```bash
cd Umurava_api
npm install
cp .env.example .env
# Update .env with your database credentials
npx prisma migrate dev
npx prisma generate
npm run dev
```

### **Database Setup**
```bash
# Create database
createdb cyberforge_db

# Run migrations
npx prisma migrate dev

# Generate Prisma client
npx prisma generate

# (Optional) Seed database
npx prisma db seed
```

## üîß **Environment Variables**

```env
# Database Configuration
DATABASE_URL=postgresql://username:password@localhost:5432/cyberforge_db

# JWT Secret (Generate a secure random string for production)
JWT_SECRET=your-super-secret-jwt-key-change-this-in-production

# Server Configuration
PORT=5000
NODE_ENV=development
```

## üìÅ **Project Structure**

```
Umurava_api/
‚îú‚îÄ‚îÄ config/                 # Configuration files
‚îÇ   ‚îú‚îÄ‚îÄ database.js        # Database connection
‚îÇ   ‚îú‚îÄ‚îÄ env.js            # Environment variables
‚îÇ   ‚îî‚îÄ‚îÄ logger.js         # Logging configuration
‚îú‚îÄ‚îÄ controllers/           # Route controllers
‚îÇ   ‚îú‚îÄ‚îÄ authController.js
‚îÇ   ‚îú‚îÄ‚îÄ challengeController.js
‚îÇ   ‚îú‚îÄ‚îÄ vulnerabilityController.js
‚îÇ   ‚îî‚îÄ‚îÄ userController.js
‚îú‚îÄ‚îÄ middleware/           # Express middleware
‚îÇ   ‚îú‚îÄ‚îÄ authMiddleware.js
‚îÇ   ‚îú‚îÄ‚îÄ errorMiddleware.js
‚îÇ   ‚îî‚îÄ‚îÄ validateMiddleware.js
‚îú‚îÄ‚îÄ models/              # Database models (Prisma)
‚îú‚îÄ‚îÄ routes/              # API routes
‚îú‚îÄ‚îÄ services/            # Business logic services
‚îú‚îÄ‚îÄ validations/         # Input validation schemas
‚îú‚îÄ‚îÄ prisma/             # Database schema and migrations
‚îÇ   ‚îú‚îÄ‚îÄ schema.prisma
‚îÇ   ‚îî‚îÄ‚îÄ migrations/
‚îú‚îÄ‚îÄ app.js              # Express app configuration
‚îî‚îÄ‚îÄ server.js           # Server entry point
```

## üîê **Security Features**

- **JWT Authentication:** Secure token-based authentication
- **Password Hashing:** bcrypt with salt rounds for password security
- **Input Validation:** Express Validator for request validation
- **CORS Configuration:** Proper cross-origin resource sharing setup
- **Error Handling:** Comprehensive error handling middleware
- **SQL Injection Prevention:** Prisma ORM prevents SQL injection attacks

## üóÑÔ∏è **Database Schema**

### **User Model**
```prisma
model User {
  id                    String                 @id @default(uuid())
  email                 String                 @unique
  password              String
  firstName             String
  lastName              String
  createdAt             DateTime               @default(now())
  updatedAt             DateTime               @updatedAt
  challenges            Challenge[]
  vulnerabilityReports  VulnerabilityReport[]
}
```

### **Challenge Model**
```prisma
model Challenge {
  id                    String                 @id @default(uuid())
  title                 String
  description           String
  difficulty            String
  duration              Int
  targetUrl             String?
  createdAt             DateTime               @default(now())
  createdBy             String?
  creator               User?                  @relation(fields: [createdBy], references: [id])
  vulnerabilityReports  VulnerabilityReport[]
}
```

### **VulnerabilityReport Model**
```prisma
model VulnerabilityReport {
  id                String   @id @default(uuid())
  challengeId       String
  userId            String
  title             String
  severity          String
  category          String?
  description       String
  stepsToReproduce  String?
  impact            String?
  recommendation    String?
  evidence          String?
  status            String   @default("submitted")
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  
  challenge         Challenge @relation(fields: [challengeId], references: [id], onDelete: Cascade)
  user              User      @relation(fields: [userId], references: [id], onDelete: Cascade)
}
```

## üöÄ **Deployment**

### **Render Deployment**
1. Connect your GitHub repository to Render
2. Use the provided `render.yaml` configuration
3. Set up PostgreSQL database
4. Configure environment variables
5. Deploy with automatic migrations

### **Environment Variables for Production**
- `DATABASE_URL` - Automatically provided by Render PostgreSQL
- `JWT_SECRET` - Auto-generated secure random string
- `NODE_ENV` - Set to "production"
- `PORT` - Set to 10000 (Render default)

## üß™ **Testing**

```bash
# Run tests (when implemented)
npm test

# Run with coverage
npm run test:coverage
```

## üìù **API Documentation**

### **Authentication Required**
Most endpoints require a valid JWT token in the Authorization header:
```
Authorization: Bearer <your-jwt-token>
```

### **Error Responses**
All endpoints return consistent error responses:
```json
{
  "message": "Error description",
  "error": "Detailed error information"
}
```

### **Success Responses**
Successful responses include relevant data and status messages:
```json
{
  "message": "Operation successful",
  "data": { ... }
}
```

## ü§ù **Contributing**

1. Fork the repository
2. Create a feature branch
3. Make your changes
4. Add tests for new functionality
5. Submit a pull request

## üìù **License**

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

---

**Built with ‚ù§Ô∏è by the CyberForge Team**
</file>

<file path="routes/authRoute.js">
const express = require("express");
const AuthController = require("../controllers/authController");
const { body } = require("express-validator");
const validate = require("../middleware/validateMiddleware");

const router = express.Router();

// Validation rules
const signupValidation = [
    body("email").isEmail().withMessage("Valid email is required"),
    body("password").isLength({ min: 6 }).withMessage("Password must be at least 6 characters"),
    body("firstName").notEmpty().withMessage("First name is required"),
    body("lastName").notEmpty().withMessage("Last name is required")
];

const loginValidation = [
    body("email").isEmail().withMessage("Valid email is required"),
    body("password").notEmpty().withMessage("Password is required")
];

router.post("/signup", signupValidation, validate, AuthController.signup);
router.post("/login", loginValidation, validate, AuthController.login);
router.post("/logout", AuthController.logout);
router.get("/me", AuthController.getMe);

module.exports = router;
</file>

<file path="routes/challengeRoute.js">
const express = require("express");
const ChallengeController = require("../controllers/challengeController");
const challengeValidationRules = require("../validations/challengeValidation");
const validate = require("../middleware/validateMiddleware");
const authMiddleware = require("../middleware/authMiddleware");

const router = express.Router();

// Public route - anyone can view challenges
router.get("/", ChallengeController.getAll);
router.get("/:id", ChallengeController.getById);

// Protected routes - require authentication
router.post("/", authMiddleware, challengeValidationRules, validate, ChallengeController.create);
router.put("/:id", authMiddleware, challengeValidationRules, validate, ChallengeController.update);
router.delete("/:id", authMiddleware, ChallengeController.delete);

module.exports = router;
</file>

<file path="routes/communityRoute.js">
const express = require("express");
const CommunityController = require("../controllers/communityController");

const router = express.Router();

router.get("/", CommunityController.getCommunityData);

module.exports = router;
</file>

<file path="routes/contactRoute.js">
const express = require("express");
const ContactController = require("../controllers/contactController");
const { body } = require("express-validator");
const validate = require("../middleware/validateMiddleware");

const router = express.Router();

const contactValidation = [
    body("name").notEmpty().withMessage("Name is required"),
    body("email").isEmail().withMessage("Valid email is required"),
    body("message").notEmpty().withMessage("Message is required")
];

router.post("/", contactValidation, validate, ContactController.submitContact);

module.exports = router;
</file>

<file path="routes/dashboardRoute.js">
const express = require("express");
const DashboardController = require("../controllers/dashboardController");
const authMiddleware = require("../middleware/authMiddleware");

const router = express.Router();

// All dashboard routes require authentication
router.get("/stats", authMiddleware, DashboardController.getDashboardStats);
router.get("/profile", authMiddleware, DashboardController.getUserProfile);

module.exports = router;
</file>

<file path="routes/userRoute.js">
const express = require("express");
const UserController = require("../controllers/userController");
const authMiddleware = require("../middleware/authMiddleware");

const router = express.Router();

// All user routes require authentication
router.use(authMiddleware);

router.get("/profile", UserController.getProfile);
router.put("/profile", UserController.updateProfile);
router.put("/change-password", UserController.changePassword);
router.put("/update-email", UserController.updateEmail);
router.post("/upload-profile-image", UserController.uploadProfileImage);
router.get("/dashboard-stats", UserController.getDashboardStats);

module.exports = router;
</file>

<file path="routes/vulnerabilityRoute.js">
const express = require("express");
const VulnerabilityController = require("../controllers/vulnerabilityController");
const authMiddleware = require("../middleware/authMiddleware");

const router = express.Router();

// All vulnerability routes require authentication
router.use(authMiddleware);

// Submit vulnerability reports for a challenge
router.post("/submit", VulnerabilityController.submitReports);

// Get vulnerability reports for a specific challenge (user's own reports)
router.get("/challenge/:challengeId", VulnerabilityController.getReportsByChallenge);

// Get all vulnerability reports by the authenticated user
router.get("/user", VulnerabilityController.getAllUserReports);

module.exports = router;
</file>

<file path="server.js">
const app = require("./app");
const { PORT } = require("./config/env");

const port = PORT || process.env.PORT || 5000;

app.listen(port, '0.0.0.0', () => {
  console.log(`üöÄ CyberForge API Server running on port ${port}`);
  console.log(`üìä Environment: ${process.env.NODE_ENV || 'development'}`);
  console.log(`üîó Health check: http://localhost:${port}/api/health`);
});
</file>

<file path="services/challengeService.js">
const prisma = require("../config/database");

const ChallengeService = {
    async createChallenge(data) {
        return prisma.challenge.create({ data });
    },

    async getAllChallenges(filters) {
        const { search, sortBy = "createdAt", order = "desc", page = 1, limit = 10 } = filters;
        const skip = (page - 1) * limit;

        const where = search
            ? { title: { contains: search, mode: "insensitive" } }
            : {};

        return prisma.challenge.findMany({
            where,
            orderBy: { [sortBy]: order },
            skip: parseInt(skip),
            take: parseInt(limit),
        });
    },

    async getChallengeById(id) {
        return prisma.challenge.findUnique({ where: { id } });
    },

    async updateChallenge(id, data) {
        return prisma.challenge.update({
            where: { id },
            data,
        });
    },

    async deleteChallenge(id) {
        return prisma.challenge.delete({ where: { id } });
    }
};

module.exports = ChallengeService;
</file>

<file path="validations/challengeValidation.js">
const {body} = require("express-validator");

const challengeValidationRules = [
    body("title")
        .notEmpty().withMessage("Title is required")
        .isString().withMessage("Title must be a string")
        .isLength({ min: 3, max: 200 }).withMessage("Title must be between 3 and 200 characters"),

    body("description")
        .notEmpty().withMessage("Description is required")
        .isString().withMessage("Description must be a string")
        .isLength({ min: 10, max: 2000 }).withMessage("Description must be between 10 and 2000 characters"),

    body("difficulty")
        .notEmpty().withMessage("Difficulty is required")
        .isIn(["easy", "medium", "hard"]).withMessage("Difficulty must be 'easy', 'medium', or 'hard'"),

    body("duration")
        .notEmpty().withMessage("Duration is required")
        .isInt({ min: 1, max: 365 }).withMessage("Duration must be a positive integer between 1 and 365 days"),

    body("targetUrl")
        .optional()
        .isURL().withMessage("Target URL must be a valid URL")
];

module.exports = challengeValidationRules;
</file>

<file path="validations/user.validation.ts">
import {body} from "express-validator";

const challengeValidationRules = [
    body("title")
        .notEmpty().withMessage("Title is required")
        .isString().withMessage("Title must be a string")
        .isLength({ min: 3, max: 100 }).withMessage("Title must be between 3 and 100 characters"),

    body("description")
        .notEmpty().withMessage("Description is required")
        .isString().withMessage("Description must be a string")
        .isLength({ min: 10, max: 500 }).withMessage("Description must be between 10 and 500 characters"),

    body("difficulty")
        .notEmpty().withMessage("Difficulty is required")
        .isIn(["easy", "medium", "hard"]).withMessage("Difficulty must be 'easy', 'medium', or 'hard'"),

    body("duration")
        .notEmpty().withMessage("Duration is required")
        .isInt({ min: 1 }).withMessage("Duration must be a positive integer (in days)")
];

module.exports = challengeValidationRules;
</file>

</files>
